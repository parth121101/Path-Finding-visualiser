{"version":3,"sources":["components/CreateNode.jsx","Algorithms/UtilityFunctions/AllNodes.js","Algorithms/UtilityFunctions/GetNeighbours.js","Algorithms/UtilityFunctions/GetNeighbourDFS.js","Algorithms/UtilityFunctions/UnvisitedNeighbours.js","Algorithms/UtilityFunctions/NodeDistance.js","Algorithms/Dijkstra.js","Algorithms/Dfs.js","Algorithms/Bfs.js","Algorithms/UtilityFunctions/GetPathNodes.js","components/CreateGrids.jsx","components/App.jsx","index.js"],"names":["CreateNode","props","onClick","onMouseClick","row","col","id","className","style","customStyle","AllNodes","grid","allnodes","node","push","GetTheNeighbour","neighbours","length","filter","neighbour","isVisited","GetTheNeighbourDfs","UnvisitedNeighboursSetDetails","algo","neighboursUnvisited","distance","previousNode","NodeSortingByDistance","nodesUnvisited","sort","A","B","Dijkstra","startNode","endNode","nodesVisited","nearestNode","shift","isWall","Infinity","Dfs","start","end","current","stack","visitedNodesInOrder","pop","UpdateInfoOfUnvisitedNeighbors","neighbour_curr","i","Bfs","GetNodesOfPath","finishNode","nodesInPath","currentNode","unshift","CreateGrids","isStartAssigned","isEndAssigned","useState","Grid","setGrid","PathDijkstra","setPathDijkstra","NeighDijkstra","setNeighDijkstra","PathDFS","setPathDFS","NeighDFS","setNeighDFS","PathBFS","setPathBFS","NeighBFS","setNeighBFS","useEffect","Array","j","Details","AddDetails","CreateGrid","this","Math","random","handleMouseClick","AssignedGrid","AssignedNode","AssignStartEndNode","Getoriginal","current_node","ShortestPathAnimation","PathArray","setTimeout","document","getElementById","NodesVisited","PathFound","window","location","reload","backgroundColor","map","rowindex","key","colindex","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.2d567c94.chunk.js","sourcesContent":["import React from \"react\";\r\nfunction CreateNode(props) {\r\n  return <div onClick={() => props.onMouseClick(props.row, props.col)} id={\"node-\" + props.row + \"-\" + props.col} className=\"gridBlock\" style={props.customStyle}></div>;\r\n}\r\nexport default CreateNode;","// The following function is to store all the nodes present in the grid\r\nfunction AllNodes(grid){\r\n    const allnodes = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            allnodes.push(node)\r\n        }\r\n    }\r\n    return allnodes;\r\n}\r\nexport default AllNodes;","//Getting all the neighbours of a node\r\nfunction GetTheNeighbour(node,grid){\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbours.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col > 0) neighbours.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\nexport default GetTheNeighbour;","function GetTheNeighbourDfs(node,grid){\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (col > 0) neighbours.push(grid[row][col - 1]);\r\n    if (row < grid.length - 1) neighbours.push(grid[row + 1][col]);\r\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\r\n    if (row > 0) neighbours.push(grid[row - 1][col]);\r\n    return neighbours.filter(neighbour => !neighbour.isVisited);\r\n  }\r\nexport default GetTheNeighbourDfs; ","import GetTheNeighbour from \"./GetNeighbours\";\r\nimport GetTheNeighbourDfs from \"./GetNeighbourDFS\";\r\n//now since we got the neighbours we will update the info of all of these neighbours\r\nfunction UnvisitedNeighboursSetDetails(node, grid,algo) {\r\n  let neighboursUnvisited;\r\n  if(algo === \"dijkstra\"){\r\n    neighboursUnvisited = GetTheNeighbour(node, grid);\r\n  }\r\n  else{\r\n    neighboursUnvisited = GetTheNeighbourDfs(node, grid);\r\n  }\r\n    \r\n  for (const neighbour of neighboursUnvisited) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\nexport default UnvisitedNeighboursSetDetails;\r\n","// The following function will help us to sort the Nodes based on the distance from the parent node\r\nfunction NodeSortingByDistance(nodesUnvisited) {\r\n    nodesUnvisited.sort(function(A, B) {\r\n        return A.distance - B.distance\r\n    });\r\n}\r\nexport default NodeSortingByDistance;","import AllNodes from \"./UtilityFunctions/AllNodes\";\r\nimport UnvisitedNeighboursSetDetails from \"./UtilityFunctions/UnvisitedNeighbours.js\";\r\nimport NodeSortingByDistance from \"./UtilityFunctions/NodeDistance.js\";\r\n\r\nfunction Dijkstra(grid, startNode, endNode){\r\n  const nodesUnvisited = AllNodes(grid); // initially all nodes in the grid are unvisited\r\n  const nodesVisited = [];\r\n  startNode.distance = 0;\r\n  while (!!nodesUnvisited.length) {\r\n    NodeSortingByDistance(nodesUnvisited);\r\n    const nearestNode = nodesUnvisited.shift();\r\n    \r\n    if (nearestNode.isWall){\r\n      // If wall is detected we don't visit that node\r\n      continue;\r\n    }\r\n    if (nearestNode.distance === Infinity){\r\n      // If the nearest node is at Infinity distance that means we are surronded by walls so we \r\n      // should stop here as furthur path is not avaliable.\r\n      return nodesVisited;\r\n    }\r\n    nearestNode.isVisited = true;\r\n    nodesVisited.push(nearestNode);\r\n    if (nearestNode === endNode){\r\n      // If we have reached the endNode we should return  \r\n      return nodesVisited;\r\n    }\r\n    UnvisitedNeighboursSetDetails(nearestNode, grid,\"dijkstra\");\r\n  }\r\n}\r\nexport default Dijkstra;","import UpdateInfoOfUnvisitedNeighbors from \"./UtilityFunctions/UnvisitedNeighbours.js\";\r\nimport GetTheNeighbourDfs from \"./UtilityFunctions/GetNeighbourDFS.js\";\r\nfunction Dfs(grid, start, end) {\r\n  start.distance = 0;\r\n  let stack = [start];\r\n  const visitedNodesInOrder = [];\r\n  let current;\r\n  while (stack.length !== 0) {\r\n    current = stack.pop();\r\n    if (current === end) {return visitedNodesInOrder;}\r\n    if(current.distance===Infinity){return visitedNodesInOrder;}\r\n    if (!current.isVisited) {\r\n      current.isVisited = true;\r\n      visitedNodesInOrder.push(current);\r\n      UpdateInfoOfUnvisitedNeighbors(current,grid,\"dfs\");\r\n      const neighbour_curr = GetTheNeighbourDfs(current,grid);\r\n      for (let i=0;i<neighbour_curr.length;i++) {\r\n        let neighbour = neighbour_curr[i];\r\n        if (!neighbour.isVisited && !neighbour.isWall) {\r\n          stack.push(neighbour);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\nexport default Dfs;","import UpdateInfoOfUnvisitedNeighbors from \"./UtilityFunctions/UnvisitedNeighbours.js\";\r\nimport GetTheNeighbourDfs from \"./UtilityFunctions/GetNeighbourDFS.js\";\r\nfunction Bfs(grid, start, end) {\r\n  start.distance = 0;\r\n  let stack = [start];\r\n  const visitedNodesInOrder = [];\r\n  let current;\r\n  \r\n  while (stack.length !== 0) {\r\n    current = stack.shift();\r\n    if (current === end) {return visitedNodesInOrder;}\r\n    if(current.distance===Infinity){return visitedNodesInOrder;}\r\n    if (!current.isVisited) {\r\n      current.isVisited = true;\r\n      visitedNodesInOrder.push(current);\r\n      UpdateInfoOfUnvisitedNeighbors(current,grid,\"bfs\");\r\n      const neighbour_curr = GetTheNeighbourDfs(current,grid);\r\n      for (let i=0;i<neighbour_curr.length;i++) {\r\n        let neighbour = neighbour_curr[i];\r\n        if (!neighbour.isVisited && !neighbour.isWall) {\r\n          stack.push(neighbour);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\nexport default Bfs;","// The following function is to get the nodes of the path from start to end node \r\nfunction GetNodesOfPath(finishNode) {\r\n    const nodesInPath = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInPath.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInPath;\r\n}\r\nexport default GetNodesOfPath;\r\n  ","import React, { useEffect, useState } from \"react\";\r\nimport CreateNode from \"./CreateNode\";\r\nimport Dijkstra from \"../Algorithms/Dijkstra\";\r\nimport Dfs from \"../Algorithms/Dfs\";\r\nimport Bfs from \"../Algorithms/Bfs\";\r\nimport GetNodesOfPath from \"../Algorithms/UtilityFunctions/GetPathNodes\";\r\n\r\nfunction CreateGrids(){\r\n  const NumOfCols = 35; // Will store the number of rows in the grid\r\n  const NumOfRows = 12; // Will store the number of columns in the grid\r\n  let isStartAssigned = false; // Will store if the start node is assigned or not\r\n  let isEndAssigned = false; // Will store if the end node is assigned or not\r\n  let startNode = null; // Will store the start node\r\n  let endNode = null; // Will store the end node\r\n  const [Grid, setGrid] = useState([]); // This is the hook grid of nodes \r\n  const [PathDijkstra, setPathDijkstra] = useState([]); // This is the hook to store the path in Dijkstra from start to end node\r\n  const [NeighDijkstra, setNeighDijkstra] = useState([]);// This is the hook to store all the visited nodes in Dijkstra\r\n  const [PathDFS, setPathDFS] = useState([]); // This is the hook to store the path in DFS from start to end node\r\n  const [NeighDFS, setNeighDFS] = useState([]); // This is the hook to store all the visited nodes in Dijkstra\r\n  const [PathBFS, setPathBFS] = useState([]); // This is the hook to store the path in BFS from start to end node\r\n  const [NeighBFS, setNeighBFS] = useState([]); // This is the hook to store all the visited nodes in Dijkstra\r\n  useEffect(function () {\r\n    CreateGrid();\r\n  },10);\r\n  // The following function will assign the grid with rows and coloumns specified \r\n  function CreateGrid(){\r\n    const grid = new Array(NumOfRows);\r\n    for (let i = 0; i < NumOfRows; i++) {\r\n      grid[i] = new Array(NumOfCols);\r\n    }  \r\n    AddDetails(grid);\r\n    setGrid(grid);\r\n  }\r\n  // The following two function will add some identity to the nodes of the grid\r\n  function AddDetails(grid) {\r\n    for (let i = 0; i < NumOfRows; i++) {\r\n      for (let j = 0; j < NumOfCols; j++) {\r\n        grid[i][j] = new Details(i, j);\r\n      }\r\n    }\r\n  }\r\n  class Details {\r\n    constructor(i, j) {\r\n      this.row = i; // To store the row number\r\n      this.col = j; // To store the column number\r\n      this.distance = Infinity; // To store its distance from the start node\r\n      this.isVisited = false; // To store if it is visited or not\r\n      this.isWall = false; // To store if its a wall or not\r\n      this.previousNode = null; // To store its previous nodes\r\n      if (Math.random(1) < 0.2) {\r\n        // To randomly assign 20% nodes with walls \r\n        this.isWall = true;\r\n      }\r\n      this.start = false; // To store if the node is start node or not\r\n      this.end = false; // To store if the node is end node or not\r\n      // If we don't want to choose start and end manually we can fix it\r\n      // this.start = (i==0 && j==0)?true:false;\r\n      // this.end = (i==6 && j==10)?true:false;\r\n    }\r\n  }\r\n  // The following two functions will assign the start and end node with the mouse click\r\n  function handleMouseClick(row,col){\r\n    const AssignedGrid  = AssignStartEndNode(Grid,row,col);\r\n    setGrid(AssignedGrid);\r\n  }\r\n  function AssignStartEndNode(Grid,row,col) {\r\n    const AssignedGrid = Grid;\r\n    const node = AssignedGrid[row][col];\r\n    // A new copy grid id made and the node which is click is set to start node and if already start node then to end node\r\n    // Rest all nodes remain as it is\r\n    const AssignedNode = {\r\n      ...node,\r\n      start: (!isStartAssigned)?true:false, // If the start node is assigned we check if end node is assigned or not\r\n      end: (isStartAssigned && !isEndAssigned)?true:false // If the end node is also assigned then no need to do response on the click\r\n    };\r\n    if(!isStartAssigned){\r\n      isStartAssigned=true; \r\n    }\r\n    else if(!isEndAssigned){\r\n      isEndAssigned=true;\r\n    }    \r\n    AssignedGrid[row][col] = AssignedNode;\r\n    return AssignedGrid;\r\n  }\r\n  // The following function assigns the locally assigned start and end nodes to the variables startNode and endNode\r\n  function SetNodes(){\r\n    for(let i=0;i<NumOfRows;i++){\r\n      for(let j=0;j<NumOfCols;j++){\r\n        if(Grid[i][j].start === true){\r\n          startNode = Grid[i][j];\r\n        }\r\n        else if(Grid[i][j].end === true){\r\n          endNode = Grid[i][j];\r\n        }\r\n      }\r\n    }\r\n    // Also this function checks if the startNode and endNode are assigned and if they are assigned it compleates all the \r\n    // path finding algorithms and save the result in the Path and visited node array.\r\n    if(startNode!==null && endNode!==null){\r\n      let NodesVisited = Dijkstra(Grid,startNode, endNode);\r\n      let PathFound = GetNodesOfPath(endNode);\r\n      setNeighDijkstra(NodesVisited);\r\n      setPathDijkstra(PathFound);\r\n      Getoriginal();\r\n      NodesVisited = Dfs(Grid,startNode, endNode);\r\n      PathFound = GetNodesOfPath(endNode);\r\n      setNeighDFS(NodesVisited);\r\n      setPathDFS(PathFound);\r\n      Getoriginal();\r\n      NodesVisited = Bfs(Grid,startNode, endNode);\r\n      PathFound = GetNodesOfPath(endNode);\r\n      setNeighBFS(NodesVisited);\r\n      setPathBFS(PathFound);\r\n      Getoriginal();\r\n    }\r\n  }\r\n  // After every path finding algorithm the details of the nodes are updated, so to reset it to the original details \r\n  // the following function is used \r\n  function Getoriginal(){\r\n    for(let i=0;i<NumOfRows;i++){\r\n      for(let j=0;j<NumOfCols;j++){\r\n        const current_node = Grid[i][j];\r\n        current_node.distance = Infinity;\r\n        current_node.isVisited = false;\r\n        current_node.previousNode = null;\r\n      }\r\n    }\r\n  }\r\n  // The following function fully visualizes the dijkstra Algorithm with all visited nodes and also the path found\r\n  function VisualizeDijkstra(){\r\n    for(let i=0;i<NumOfRows;i++){\r\n      for(let j=0;j<NumOfCols;j++){\r\n        const current_node = Grid[i][j];\r\n        document.getElementById(\"node-\" + current_node.row + \"-\" + current_node.col).className = \"gridBlock clearNode\";\r\n      }\r\n    }\r\n    for(let i = 0; i<=NeighDijkstra.length ; i++){\r\n      if(i===NeighDijkstra.length){\r\n        setTimeout(() => {\r\n          ShortestPathAnimation(PathDijkstra,\"dijkstra\");\r\n        },20*i);\r\n      }\r\n      else{\r\n        setTimeout(() => {\r\n          const node = NeighDijkstra[i];\r\n          if(!(node.start) && !(node.end)){\r\n            document.getElementById(\"node-\" + node.row + \"-\" + node.col).className = \"gridBlock VisitedDijkstraNode VisitedNode\";\r\n          }\r\n          \r\n        },20*i);\r\n      }\r\n    }\r\n  }\r\n  // The following function fully visualizes the DFS Algorithm with all visited nodes and also the path found\r\n  function VisualizeDFS(){\r\n    for(let i=0;i<NumOfRows;i++){\r\n      for(let j=0;j<NumOfCols;j++){\r\n        const current_node = Grid[i][j];\r\n        document.getElementById(\"node-\" + current_node.row + \"-\" + current_node.col).className = \"gridBlock clearNode\";\r\n      }\r\n    }\r\n    for(let i = 0; i<=NeighDFS.length ; i++){\r\n      if(i===NeighDFS.length){\r\n        setTimeout(() => {\r\n          ShortestPathAnimation(PathDFS,\"dfs\");\r\n        },50*i);\r\n      }\r\n      else{\r\n        setTimeout(() => {\r\n          const node = NeighDFS[i];\r\n          if(!(node.start) && !(node.end)){\r\n            document.getElementById(\"node-\" + node.row + \"-\" + node.col).className = \"gridBlock VisitedDFSNode VisitedNode\";\r\n          }\r\n        },50*i);\r\n      }\r\n    }\r\n  }\r\n  // The following function fully visualizes the DFS Algorithm with all visited nodes and also the path found\r\n  function VisualizeBFS(){\r\n    for(let i=0;i<NumOfRows;i++){\r\n      for(let j=0;j<NumOfCols;j++){\r\n        const current_node = Grid[i][j];\r\n        document.getElementById(\"node-\" + current_node.row + \"-\" + current_node.col).className = \"gridBlock clearNode\";\r\n      }\r\n    }\r\n    for(let i = 0; i<=NeighBFS.length ; i++){\r\n      if(i===NeighBFS.length){\r\n        setTimeout(() => {\r\n          ShortestPathAnimation(PathBFS,\"bfs\");\r\n        },20*i);\r\n      }\r\n      else{\r\n        setTimeout(() => {\r\n          const node = NeighBFS[i];\r\n          if(!(node.start) && !(node.end)){\r\n            document.getElementById(\"node-\" + node.row + \"-\" + node.col).className = \"gridBlock VisitedBFSNode VisitedNode\";\r\n          }\r\n        },20*i);\r\n      }\r\n    }\r\n  }\r\n  function ShortestPathAnimation(PathArray,algo){\r\n    for(let i = 1; i<PathArray.length-1; i++){\r\n      setTimeout(() => {\r\n        const node = PathArray[i];\r\n        if(algo===\"dijkstra\"){\r\n          document.getElementById(\"node-\" + node.row + \"-\" + node.col).className = \"gridBlock PathNodes PathDijkstraNodes\";\r\n        }\r\n        else if(algo===\"bfs\"){\r\n          document.getElementById(\"node-\" + node.row + \"-\" + node.col).className = \"gridBlock PathNodes PathBFSNodes\";\r\n        }\r\n        else if(algo===\"dfs\"){\r\n          document.getElementById(\"node-\" + node.row + \"-\" + node.col).className = \"gridBlock PathNodes PathDFSNodes\";\r\n        }\r\n      }, 30*i);\r\n    }\r\n  }\r\n  // The following function is used to reset the grid with different wall positions\r\n  function reset(){\r\n    window.location.reload(false);\r\n  }\r\n  return(\r\n    <div className=\"gridWrapper\">\r\n      <div className=\"buttons\">\r\n        <button className = \"btn dijkstra  btn-lg btn-info\" onClick={VisualizeDijkstra}>Dijkstra</button>\r\n        <button className = \"btn bfs  btn-lg btn-info\" onClick={VisualizeBFS}>BFS</button>\r\n        <button className = \"btn dfs  btn-lg btn-info\" onClick={VisualizeDFS}>DFS</button>\r\n        <button className = \"btn setNodes  btn-lg btn-info\" onClick={SetNodes}>Set Nodes</button>\r\n        <button className = \"btn reset btn-lg btn-info\" onClick={reset}>Reset</button>\r\n      </div>\r\n      <div className=\"Headers\">\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"green\"}}></div>\r\n        <span className=\"subHeading\">Start Node</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"purple\"}}></div>\r\n        <span className=\"subHeading\">End Node</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"black\"}}></div>\r\n        <span className=\"subHeading\">Wall</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"#bef9b2\"}}></div>\r\n        <span className=\"subHeading\">Dijkstra spread</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"#fc0026\"}}></div>\r\n        <span className=\"subHeading\">Dijkstra path</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"#8ecdf8\"}}></div>\r\n        <span className=\"subHeading\">BFS spread</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"#FFC900\"}}></div>\r\n        <span className=\"subHeading\">BFS path</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"#F6C6EA\"}}></div>\r\n        <span className=\"subHeading\">DFS spread</span>\r\n        <div className=\"colorHeader\" style={{backgroundColor: \"#f77a44\"}}></div>\r\n        <span className=\"subHeading\">DFS path</span> \r\n      </div>\r\n      {Grid.map(function(row, rowindex){\r\n        return (\r\n          <div key={rowindex} className=\"GridRowWrapper\">\r\n            {row.map(function(col, colindex) {\r\n              return <CreateNode onMouseClick={(row, col) => handleMouseClick(row, col)} row={rowindex} col={colindex} key={colindex} customStyle = {col.start?{backgroundColor: \"green\"}:col.end?{backgroundColor:\"purple\"}:col.isWall?{backgroundColor:\"black\"}:{}} />;\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CreateGrids;","import React from \"react\";\r\nimport CreateGrids from \"./CreateGrids\";\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <div  className=\"heading\">\r\n        <h1>Path Finding Algorithms</h1>\r\n        {/* <button className = \"btn reset btn-lg btn-info\" >Help</button> */}\r\n      </div>\r\n      <CreateGrids />\r\n      <div className=\"copyright\"><h6>Â© Namarth 2022</h6></div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./components/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}